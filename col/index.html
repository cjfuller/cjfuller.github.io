<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><title>Col: a modular collection of utilities for common lisp</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x">Col:<span class="mywbr"> &nbsp;</span> a modular collection of utilities for common lisp</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._mappings%29" class="tocviewlink" data-pltdoc="x">Mappings</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._threading%29" class="tocviewlink" data-pltdoc="x">Threading macro</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._reader%29" class="tocviewlink" data-pltdoc="x">Reader macros</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._strings%29" class="tocviewlink" data-pltdoc="x">Strings</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._io%29" class="tocviewlink" data-pltdoc="x">IO</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._misc%29" class="tocviewlink" data-pltdoc="x">Miscellaneous</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._.Col__a_modular_collection_of_utilities_for_common_lisp%29" class="tocsubseclink" data-pltdoc="x">Col:<span class="mywbr"> &nbsp;</span> a modular collection of utilities for common lisp</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._mappings%29" class="tocsubseclink" data-pltdoc="x">Mappings</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._map-interface%29" class="tocsubseclink" data-pltdoc="x">Common mapping interface</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Utility%29" class="tocsubseclink" data-pltdoc="x">Utility</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._threading%29" class="tocsubseclink" data-pltdoc="x">Threading macro</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._reader%29" class="tocsubseclink" data-pltdoc="x">Reader macros</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._map._literal._reader%29" class="tocsubseclink" data-pltdoc="x">Map literal reader</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._shell._command._literals%29" class="tocsubseclink" data-pltdoc="x">Shell command literals</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._enabling._reader._syntax%29" class="tocsubseclink" data-pltdoc="x">Enabling reader syntax</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._strings%29" class="tocsubseclink" data-pltdoc="x">Strings</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._io%29" class="tocsubseclink" data-pltdoc="x">IO</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._misc%29" class="tocsubseclink" data-pltdoc="x">Miscellaneous</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">6.1</span></div><h2><a name="(part._.Col__a_modular_collection_of_utilities_for_common_lisp)"></a>Col: a modular collection of utilities for common lisp</h2><p><a href="//github.com/cjfuller/col">Col</a> is a collection of common lisp
utilities that I&rsquo;ve found useful in my own projects.  I&rsquo;ve provided them in a
series of mostly independent packages in hopes that they can be used together
or in a take-only-what-you-like manner.</p><p>It currently consists of four major things:</p><ul><li><p>A <a href="#%28part._mappings%29" data-pltdoc="x">mapping interface</a> that can be used with all the major mapping
  types (preference lists, association lists, hash tables,
  <a href="https://common-lisp.net/project/fset/Site/index.html">FSet maps</a>)</p></li><li><p>A <a href="#%28part._reader%29" data-pltdoc="x">reader extension for mapping literals</a></p></li><li><p>A <a href="#%28part._threading%29" data-pltdoc="x">clojure-style threading macro</a>, with associated utilities</p></li><li><p>Miscellaneous convenience functions/macros/reader macros.</p></li></ul><p>See the individual sections in the table of contents for detailed documentation
on each package.</p><p>There&rsquo;s also a meta-package (col) that re-exports the contents of all the other packages.</p><h3>1<tt>&nbsp;</tt><a name="(part._mappings)"></a>Mappings</h3><p>Package <span class="RktSym">col.mapping</span><span class="RktMeta"></span></p><h4>1.1<tt>&nbsp;</tt><a name="(part._map-interface)"></a>Common mapping interface</h4><p>To implement the common mapping interface, three generic functions must be
implemented for a type: <span class="RktSym">mget</span><span class="RktMeta"></span>, <span class="RktSym">mset</span><span class="RktMeta"></span>, and <span class="RktSym">keys</span><span class="RktMeta"></span>.  Optionally,
if the mapping type is mutable, implement <span class="RktSym">mset!</span><span class="RktMeta"></span>.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>generic</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">mget</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">t</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Get the value associated with key in the provided mapping.  (Generic function.)</div></p><p>If the value is not present in the mapping, return <span class="RktSym">nil</span><span class="RktMeta"></span>.</p><p>Implementations are provide for association lists, preference lists,
hash-tables, and FSet maps.  For association lists and preference lists, keys
are compared using <span class="RktSym">equal</span><span class="RktMeta"></span>.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">mget*</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">t</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Get the value associated with the supplied keys in a nested mapping.  Keys
should be supplied in outermost to innermost order.  If any key is absent,
return nil.  Implemented in terms of <span class="RktSym">mget</span><span class="RktMeta"></span>.</div></p><p>Example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">mget*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">my-map</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote><p><div class="SIntrapara">is equivalent to:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">mget</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">mget</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">my-map</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>generic</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">mset</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Set the value associated with the supplied key in a mapping.  Return a new
mapping object.  The original is unchanged.</div></p><p>Note that for alists and plists, this will just cons onto the front of the
list, even if other instances of the key already exist in the map.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">mset*</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span><span class="RktVar">keylist</span><span class="hspace">&nbsp;</span><span class="RktVar">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">keylist</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Set the value associated with the supplied keys in a nested mapping.  Return a new
mapping object.  The original is unchanged at any depth.</div></p><p><div class="SIntrapara">Example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">mset*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">my-map</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">b</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara">is equivalent to:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">mset</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">my-map</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">mset</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">mget</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">my-map</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">a</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">b</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">mset&amp;</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara"><span class="RktSym">mset</span><span class="RktMeta"></span> and rebind.  Set the value associated with key in the mapping
without modification.  <span class="RktSym">mapping</span><span class="RktMeta"></span> should be a <span class="RktSym">setf</span><span class="RktMeta"></span>able place.
<span class="RktSym">setf</span><span class="RktMeta"></span> the place to the new mapping and return that new mapping.</div></p><p><div class="SIntrapara">Example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">(defvar</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">#M{:a</span><span class="hspace">&nbsp;</span><span class="RktMeta">1</span><span class="hspace">&nbsp;</span><span class="RktMeta">:b</span><span class="hspace">&nbsp;</span><span class="RktMeta">2})</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">(defvar</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta">x)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">&#160;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">(mset&amp;</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">:a</span><span class="hspace">&nbsp;</span><span class="RktMeta">5)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">After running this, <span class="RktSym">x</span><span class="RktMeta"></span> is now <span class="RktPn">{</span><span class="RktSym">:a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">5</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:b</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">}</span><span class="RktMeta"></span>, but <span class="RktSym">y</span><span class="RktMeta"></span> is still
the original <span class="RktPn">{</span><span class="RktSym">:a</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">:b</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">}</span><span class="RktMeta"></span></div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">mset!</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">t</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Set the value associated with the supplied key in a mutable mapping.  Return
the value.  The mapping is modified in place.</div></p><p>This will cause an error for FSet maps and plists.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>generic</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">keys</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">list</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr></table></blockquote></div><div class="SIntrapara">Get all the keys in the provided mapping as a list.</div></p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Utility)"></a>Utility</h4><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">alist-p</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">member</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">nil</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr></table></blockquote></div><div class="SIntrapara">Is the provided mapping an association list?</div></p><p>Assumes that if the argument is a list, it&rsquo;s either an alist or a plist.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">plist-p</span></span><span class="hspace">&nbsp;</span><span class="RktVar">mapping</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">member</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">nil</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">mapping</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktVar">mapping</span></td></tr></table></blockquote></div><div class="SIntrapara">Is the provided mapping a preference list?</div></p><p>Assumes that if the argument is a list, it&rsquo;s either an alist or a plist.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">remove-from-plist</span></span><span class="hspace">&nbsp;</span><span class="RktVar">plist</span><span class="hspace">&nbsp;</span><span class="RktVar">k</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">list</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">plist</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">list</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">k</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Remove the provided key and its associated value from the plist.</div></p><p>Don&rsquo;t modify the original.  Return a new plist with all copies of the key and
their values removed.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">hset</span></span><span class="hspace">&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span><span class="RktVar">value</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">t</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">hash-table</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">key</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">value</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">An argument-order-consistent shorthand for setting a value in a hash-table.</div></p><p>Return the value being set.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">htcopy</span></span><span class="hspace">&nbsp;</span><span class="RktVar">hash</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">hash-table</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">hash-table</span></td></tr></table></blockquote></div><div class="SIntrapara">Shallow copy a hash table.  The parameters used to construct the original table
are the same for the new table.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">plist-&gt;alist</span></span><span class="hspace">&nbsp;</span><span class="RktVar">plist</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">list</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">plist</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">list</span></td></tr></table></blockquote></div><div class="SIntrapara">Convert a plist to an alist.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">alist-&gt;ht</span></span><span class="hspace">&nbsp;</span><span class="RktVar">alist</span><span class="hspace">&nbsp;</span><span class="RktVar">hash-table-initargs</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">hash-table</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">alist</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">list</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">hash-table-initargs</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Convert an alist to a hash table.</div></p><h3>2<tt>&nbsp;</tt><a name="(part._threading)"></a>Threading macro</h3><p>Package <span class="RktSym">col.threading</span><span class="RktMeta"></span></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym"><span class="nobreak">-&gt;</span></span></span><span class="hspace">&nbsp;</span><span class="RktVar">first</span><span class="hspace">&nbsp;</span><span class="RktVar">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">t</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">first</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">body</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Clojure-style threading macro.</div></p><p>Insert the first form into the first argument position of the second form.
Evaluate and insert the result into the first argument position of the next
form.  Repeat until no more forms remain.</p><p><div class="SIntrapara">Example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">rmapcar</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">#'</span><span class="RktSym">1+</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">car</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div><div class="SIntrapara">would return 2.</div></p><p>If you want to call a function with the inserted argument as the only argument,
you can just use the bare function name (not sharp-quoted).</p><p><div class="SIntrapara">Example:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktPn">(</span><span class="RktVal">1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">3</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktSym">rmapcar</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">#'</span><span class="RktSym">1+</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">car</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">rmapcar</span></span><span class="hspace">&nbsp;</span><span class="RktVar">lst</span><span class="hspace">&nbsp;</span><span class="RktVar">fn</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">list</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">lst</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">list</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">fn</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="nobreak">-&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara"><span class="RktSym">mapcar</span><span class="RktMeta"></span>, but with the argument order reversed.
This allows passing the list argument using the threading macro.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">tee</span></span><span class="hspace">&nbsp;</span><span class="RktVar">first</span><span class="hspace">&nbsp;</span><span class="RktVar">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">list</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">first</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">body</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Tee-like macro for use with the threading macro.</div></p><p>Insert first into the first argument position in each of the body forms using
the threading macro.  Collect the results of the body forms into a list.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">tap</span></span><span class="hspace">&nbsp;</span><span class="RktVar">first</span><span class="hspace">&nbsp;</span><span class="RktVar">form</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">t</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">first</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">form</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Tap into the threading macro, evaluating a form for side-effects.</div></p><p><span class="RktSym">first</span><span class="RktMeta"></span> is inserted into the first argument position of <span class="RktSym">form</span><span class="RktMeta"></span> using
the threading macro, the form is evaluated (discarding the result), and
<span class="RktSym">first</span><span class="RktMeta"></span> is returned.</p><h3>3<tt>&nbsp;</tt><a name="(part._reader)"></a>Reader macros</h3><p>Package <span class="RktSym">col.reader</span><span class="RktMeta"></span></p><h4>3.1<tt>&nbsp;</tt><a name="(part._map._literal._reader)"></a>Map literal reader</h4><p>The map literal reader adds a syntax for literals of an arbitrary mapping type:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">#M(opts-plist){key</span><span class="hspace">&nbsp;</span><span class="RktMeta">value</span><span class="hspace">&nbsp;</span><span class="RktMeta">key</span><span class="hspace">&nbsp;</span><span class="RktMeta">value</span><span class="hspace">&nbsp;</span><span class="RktMeta">...}</span><span class="RktMeta"></span></td></tr></table></blockquote><p><span class="RktSym">opts-plist</span><span class="RktMeta"></span> is a completely (even parentheses) optional preference list
of options that specify the result type of the mapping.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">opts-plist</span><span class="RktPn">)</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktPn">(</span><span class="RktSym">option</span><span class="hspace">&nbsp;</span><span class="RktSym">...</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara"><table cellspacing="0" cellpadding="0"><tr><td align="right" valign="baseline"><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">option</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">=</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">:type</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktVar">member</span><span class="hspace">&nbsp;</span><span class="RktVar">:alist</span><span class="hspace">&nbsp;</span><span class="RktVar">:plist</span><span class="hspace">&nbsp;</span><span class="RktVar">:hash-table</span><span class="hspace">&nbsp;</span><span class="RktVar">:fset-map</span><span class="RktPn">)</span></td></tr><tr><td align="right" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="center" valign="baseline">|</td><td align="left" valign="baseline"><span class="stt">&nbsp;</span></td><td align="left" valign="baseline"><span class="RktVar">:test</span><span class="hspace">&nbsp;</span><span class="RktVar">test</span></td></tr></table></div></p><p>If no option is specified, the default is <span class="RktSym">*default-map-literal-type*</span><span class="RktMeta"></span>.</p><p><span class="RktSym">:test</span><span class="RktMeta"></span> is only used when the output type is <span class="RktSym">:hash-table</span><span class="RktMeta"></span></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>dynamic var</p></div></div><p class="RForeground"><span class="RktSym"><span class="RktSymDef RktSym">*default-map-literal-type*</span></span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">keyword</span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktSym">:alist</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Default map literal type to use when one is not supplied.</div></p><h4>3.2<tt>&nbsp;</tt><a name="(part._shell._command._literals)"></a>Shell command literals</h4><p>The shell command literal reader adds a syntax for running a shell
command (using <a href="http://quickdocs.org/inferior-shell">inferior-shell</a>)
and returning standard output as a string.</p><p>Example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">#!"ls</span><span class="hspace">&nbsp;</span><span class="RktMeta">-al</span><span class="hspace">&nbsp;</span><span class="RktMeta">/"</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Within the string, interpolation using
<a href="http://weitz.de/cl-interpol/">cl-interpol</a> syntax is available.</p><h4>3.3<tt>&nbsp;</tt><a name="(part._enabling._reader._syntax)"></a>Enabling reader syntax</h4><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">enable-reader-exts</span></span><span class="hspace">&nbsp;</span>[<span class="RktPn">#:do-push</span><span class="hspace">&nbsp;</span><span class="RktVar">do-push</span>]<span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">void</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">do-push</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">member</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">nil</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Enable the map literal and shell command literal readers.  Also enables
cl-interpol <span class="RktMeta"></span><span class="RktMeta">#?""</span><span class="RktMeta"></span> syntax.</div></p><p>If <span class="RktSym">do-push</span><span class="RktMeta"></span> is nil, modify the readtable in place, rather than pushing on
a copy that can be popped using <span class="RktSym">pop-reader-exts</span><span class="RktMeta"></span>.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">enable-map-literals</span></span><span class="hspace">&nbsp;</span>[<span class="RktPn">#:do-push</span><span class="hspace">&nbsp;</span><span class="RktVar">do-push</span>]<span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">void</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">do-push</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">member</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">nil</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Enable only the map literal syntax.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">enable-shell-command-literals</span></span><span class="hspace">&nbsp;</span>[<span class="RktPn">#:do-push</span><span class="hspace">&nbsp;</span><span class="RktVar">do-push</span>]<span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">void</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">do-push</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">member</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">nil</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Enable only the shell command literal syntax.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">pop-reader-exts</span></span><span class="RktPn"></span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">void</span><span class="RktPn">)</span></p></blockquote></td></tr></table></blockquote></div><div class="SIntrapara">Disable the most recently added reader syntax from this package.  (Calls to
this macro should be matched one-to-one with calls to any of the
<span class="RktSym">enable-</span><span class="RktMeta"></span> macros.)</div></p><h3>4<tt>&nbsp;</tt><a name="(part._strings)"></a>Strings</h3><p>Package <span class="RktSym">col.strings</span><span class="RktMeta"></span></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">&lt;&gt;</span></span><span class="hspace">&nbsp;</span><span class="RktVar">strings</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">string</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">strings</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">string</span></td></tr></table></blockquote></div><div class="SIntrapara">Shorthand for concatenating strings.</div></p><p><div class="SIntrapara">Same as:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">concatenate</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">'</span><span class="RktSym">string</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">strings</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>generic</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym"><span class="nobreak">-&gt;</span>string</span></span><span class="hspace">&nbsp;</span><span class="RktVar">obj</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">or</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">eql</span><span class="hspace">&nbsp;</span><span class="RktVar">obj</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym">string</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">obj</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Generic for converting an object to string.</div></p><p>The default implementation is a no-op, returning obj.  This is used when
calling <span class="RktSym">println</span><span class="RktMeta"></span> from the <span class="RktSym">col.io</span><span class="RktMeta"></span> package and can be used to make a
custom printed representation.</p><h3>5<tt>&nbsp;</tt><a name="(part._io)"></a>IO</h3><p>Package <span class="RktSym">col.io</span><span class="RktMeta"></span></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">println</span></span><span class="hspace">&nbsp;</span><span class="RktVar">s</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">nil</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">s</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Call <span class="RktSym"><span class="nobreak">-&gt;</span>string</span><span class="RktMeta"></span> (from <span class="RktSym">col.io</span><span class="RktMeta"></span>) on the input, then <span class="RktSym">princ</span><span class="RktMeta"></span> it,
followed by a newline.</div></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>procedure</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">slurp</span></span><span class="hspace">&nbsp;</span><span class="RktVar">fn</span><span class="hspace">&nbsp;</span>[<span class="RktPn">#:lines</span><span class="hspace">&nbsp;</span><span class="RktVar">lines</span>]<span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">or</span><span class="hspace">&nbsp;</span><span class="RktSym">string</span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">string</span><span class="RktPn">)</span><span class="RktPn">)</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">fn</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">or</span><span class="hspace">&nbsp;</span><span class="RktSym">string</span><span class="hspace">&nbsp;</span><span class="RktSym">pathname</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">lines</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">member</span><span class="hspace">&nbsp;</span><span class="RktSym">t</span><span class="hspace">&nbsp;</span><span class="RktSym">nil</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>=<span class="hspace">&nbsp;</span><span class="RktSym">nil</span></td></tr></table></blockquote></div><div class="SIntrapara">Slurp a file into a string, given a filename string or pathname.</div></p><p>If lines is non-nil, instead of a string, return a list with one string per
line (newlines stripped).</p><h3>6<tt>&nbsp;</tt><a name="(part._misc)"></a>Miscellaneous</h3><p>Package <span class="RktSym">col.misc</span><span class="RktMeta"></span></p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">nthval</span></span><span class="hspace">&nbsp;</span><span class="RktVar">values-returning</span><span class="hspace">&nbsp;</span><span class="RktVar">n</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">t</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">values-returning</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">n</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">integer</span></td></tr></table></blockquote></div><div class="SIntrapara">Get the nth value (0-indexed) of a form returning multiple values.</div></p><p>Note that the arguments are in reverse order from <span class="RktSym">nth</span><span class="RktMeta"></span> for lists, so that
this can be used in the threading macro.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">nthvals</span></span><span class="hspace">&nbsp;</span><span class="RktVar">values-returning</span><span class="hspace">&nbsp;</span><span class="RktVar">nlist</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">list</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">values-returning</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">nlist</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">listof</span><span class="hspace">&nbsp;</span><span class="RktSym">integer</span><span class="RktPn">)</span></td></tr></table></blockquote></div><div class="SIntrapara">Get the values at the supplied positions of a form returning multiple values.</div></p><p>Note that the arguments are in reverse order from <span class="RktSym">nth</span><span class="RktMeta"></span> for lists, so that
this can be used in the threading macro.</p><p><div class="SIntrapara"><blockquote class="SVInsetFlow"><table cellspacing="0" cellpadding="0" class="boxed RBoxed"><tr><td><blockquote class="SubFlow"><div class="RBackgroundLabel SIEHidden"><div class="RBackgroundLabelInner"><p>macro</p></div></div><p class="RForeground"><span class="RktPn">(</span><span class="RktSym"><span class="RktSymDef RktSym">:=</span></span><span class="hspace">&nbsp;</span><span class="RktVar">var</span><span class="hspace">&nbsp;</span><span class="RktVar">val</span><span class="hspace">&nbsp;</span><span class="RktVar">body</span><span class="hspace">&nbsp;</span><span class="RktMeta">...</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span>&rarr;<span class="hspace">&nbsp;</span><span class="RktSym">t</span></p></blockquote></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">var</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">symbol</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">val</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktVar">body</span><span class="hspace">&nbsp;</span>:<span class="hspace">&nbsp;</span><span class="RktSym">t</span></td></tr></table></blockquote></div><div class="SIntrapara">Extremely gratuitous shorthand for let with a single binding:
</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym">let</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktPn">(</span><span class="RktSym">var</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">val</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktSym">body</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktSym">...</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr></table></blockquote></div></p><p>This occasionally improves readability.  Will be deprecated or renamed in a
future release to avoid confusion because of the colon.</p></div></div><div id="contextindicator">&nbsp;</div></body></html>